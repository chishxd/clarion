"""
This type stub file was generated by pyright.
"""

import contextlib
from abc import ABCMeta, abstractmethod
from ._multiprocessing_helpers import mp

"""
Backends for embarrassingly parallel code.
"""
if mp is not None:
    ...
class ParallelBackendBase(metaclass=ABCMeta):
    """Helper abc which defines all methods a ParallelBackend must implement"""
    default_n_jobs = ...
    supports_inner_max_num_threads = ...
    supports_retrieve_callback = ...
    @property
    def supports_return_generator(self): # -> bool:
        ...
    
    @property
    def supports_timeout(self): # -> bool:
        ...
    
    nesting_level = ...
    def __init__(self, nesting_level=..., inner_max_num_threads=..., **backend_kwargs) -> None:
        ...
    
    MAX_NUM_THREADS_VARS = ...
    TBB_ENABLE_IPC_VAR = ...
    @abstractmethod
    def effective_n_jobs(self, n_jobs): # -> None:
        """Determine the number of jobs that can actually run in parallel

        n_jobs is the number of workers requested by the callers. Passing
        n_jobs=-1 means requesting all available workers for instance matching
        the number of CPU cores on the worker host(s).

        This method should return a guesstimate of the number of workers that
        can actually perform work concurrently. The primary use case is to make
        it possible for the caller to know in how many chunks to slice the
        work.

        In general working on larger data chunks is more efficient (less
        scheduling overhead and better use of CPU cache prefetching heuristics)
        as long as all the workers have enough work to do.
        """
        ...
    
    def apply_async(self, func, callback=...):
        """Deprecated: implement `submit` instead."""
        ...
    
    def submit(self, func, callback=...):
        """Schedule a function to be run and return a future-like object.

        This method should return a future-like object that allow tracking
        the progress of the task.

        If ``supports_retrieve_callback`` is False, the return value of this
        method is passed to ``retrieve_result`` instead of calling
        ``retrieve_result_callback``.

        Parameters
        ----------
        func: callable
            The function to be run in parallel.

        callback: callable
            A callable that will be called when the task is completed. This callable
            is a wrapper around ``retrieve_result_callback``. This should be added
            to the future-like object returned by this method, so that the callback
            is called when the task is completed.

            For future-like backends, this can be achieved with something like
            ``future.add_done_callback(callback)``.

        Returns
        -------
        future: future-like
            A future-like object to track the execution of the submitted function.
        """
        ...
    
    def retrieve_result_callback(self, out): # -> None:
        """Called within the callback function passed to `submit`.

        This method can customise how the result of the function is retrieved
        from the future-like object.

        Parameters
        ----------
        future: future-like
            The future-like object returned by the `submit` method.

        Returns
        -------
        result: object
            The result of the function executed in parallel.
        """
        ...
    
    def retrieve_result(self, out, timeout=...):
        """Hook to retrieve the result when support_retrieve_callback=False.

        The argument `out` is the result of the `submit` call. This method
        should return the result of the computation or raise an exception if
        the computation failed.
        """
        ...
    
    def configure(self, n_jobs=..., parallel=..., prefer=..., require=..., **backend_kwargs): # -> None:
        """Reconfigure the backend and return the number of workers.

        This makes it possible to reuse an existing backend instance for
        successive independent calls to Parallel with different parameters.
        """
        ...
    
    def start_call(self): # -> None:
        """Call-back method called at the beginning of a Parallel call"""
        ...
    
    def stop_call(self): # -> None:
        """Call-back method called at the end of a Parallel call"""
        ...
    
    def terminate(self): # -> None:
        """Shutdown the workers and free the shared memory."""
        ...
    
    def compute_batch_size(self): # -> Literal[1]:
        """Determine the optimal batch size"""
        ...
    
    def batch_completed(self, batch_size, duration): # -> None:
        """Callback indicate how long it took to run a batch"""
        ...
    
    def abort_everything(self, ensure_ready=...): # -> None:
        """Abort any running tasks

        This is called when an exception has been raised when executing a task
        and all the remaining tasks will be ignored and can therefore be
        aborted to spare computation resources.

        If ensure_ready is True, the backend should be left in an operating
        state as future tasks might be re-submitted via that same backend
        instance.

        If ensure_ready is False, the implementer of this method can decide
        to leave the backend in a closed / terminated state as no new task
        are expected to be submitted to this backend.

        Setting ensure_ready to False is an optimization that can be leveraged
        when aborting tasks via killing processes from a local process pool
        managed by the backend it-self: if we expect no new tasks, there is no
        point in re-creating new workers.
        """
        ...
    
    def get_nested_backend(self): # -> tuple[SequentialBackend, None] | tuple[ThreadingBackend, None]:
        """Backend instance to be used by nested Parallel calls.

        By default a thread-based backend is used for the first level of
        nesting. Beyond, switch to sequential backend to avoid spawning too
        many threads on the host.
        """
        ...
    
    @contextlib.contextmanager
    def retrieval_context(self): # -> Generator[None, Any, None]:
        """Context manager to manage an execution context.

        Calls to Parallel.retrieve will be made inside this context.

        By default, this does nothing. It may be useful for subclasses to
        handle nested parallelism. In particular, it may be required to avoid
        deadlocks if a backend manages a fixed number of workers, when those
        workers may be asked to do nested Parallel calls. Without
        'retrieval_context' this could lead to deadlock, as all the workers
        managed by the backend may be "busy" waiting for the nested parallel
        calls to finish, but the backend has no free workers to execute those
        tasks.
        """
        ...
    
    @staticmethod
    def in_main_thread(): # -> bool:
        ...
    


class SequentialBackend(ParallelBackendBase):
    """A ParallelBackend which will execute all batches sequentially.

    Does not use/create any threading objects, and hence has minimal
    overhead. Used when n_jobs == 1.
    """
    uses_threads = ...
    supports_timeout = ...
    supports_retrieve_callback = ...
    supports_sharedmem = ...
    def effective_n_jobs(self, n_jobs): # -> Literal[1]:
        """Determine the number of jobs which are going to run in parallel"""
        ...
    
    def submit(self, func, callback=...):
        """Schedule a func to be run"""
        ...
    
    def retrieve_result_callback(self, out):
        ...
    
    def get_nested_backend(self): # -> tuple[Any | _Sentinel | object, _Sentinel | Any | object]:
        ...
    


class PoolManagerMixin:
    """A helper class for managing pool of workers."""
    _pool = ...
    def effective_n_jobs(self, n_jobs): # -> int:
        """Determine the number of jobs which are going to run in parallel"""
        ...
    
    def terminate(self): # -> None:
        """Shutdown the process or thread pool"""
        ...
    
    def submit(self, func, callback=...):
        """Schedule a func to be run"""
        ...
    
    def retrieve_result_callback(self, result):
        """Mimic concurrent.futures results, raising an error if needed."""
        ...
    
    def abort_everything(self, ensure_ready=...): # -> None:
        """Shutdown the pool and restart a new one with the same parameters"""
        ...
    


class AutoBatchingMixin:
    """A helper class for automagically batching jobs."""
    MIN_IDEAL_BATCH_DURATION = ...
    MAX_IDEAL_BATCH_DURATION = ...
    _DEFAULT_EFFECTIVE_BATCH_SIZE = ...
    _DEFAULT_SMOOTHED_BATCH_DURATION = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def compute_batch_size(self): # -> int:
        """Determine the optimal batch size"""
        ...
    
    def batch_completed(self, batch_size, duration): # -> None:
        """Callback indicate how long it took to run a batch"""
        ...
    
    def reset_batch_stats(self): # -> None:
        """Reset batch statistics to default values.

        This avoids interferences with future jobs.
        """
        ...
    


class ThreadingBackend(PoolManagerMixin, ParallelBackendBase):
    """A ParallelBackend which will use a thread pool to execute batches in.

    This is a low-overhead backend but it suffers from the Python Global
    Interpreter Lock if the called function relies a lot on Python objects.
    Mostly useful when the execution bottleneck is a compiled extension that
    explicitly releases the GIL (for instance a Cython loop wrapped in a "with
    nogil" block or an expensive call to a library such as NumPy).

    The actual thread pool is lazily initialized: the actual thread pool
    construction is delayed to the first call to apply_async.

    ThreadingBackend is used as the default backend for nested calls.
    """
    supports_retrieve_callback = ...
    uses_threads = ...
    supports_sharedmem = ...
    def configure(self, n_jobs=..., parallel=..., **backend_kwargs): # -> int:
        """Build a process or thread pool and return the number of workers"""
        ...
    


class MultiprocessingBackend(PoolManagerMixin, AutoBatchingMixin, ParallelBackendBase):
    """A ParallelBackend which will use a multiprocessing.Pool.

    Will introduce some communication and memory overhead when exchanging
    input and output data with the with the worker Python processes.
    However, does not suffer from the Python Global Interpreter Lock.
    """
    supports_retrieve_callback = ...
    supports_return_generator = ...
    def effective_n_jobs(self, n_jobs): # -> int:
        """Determine the number of jobs which are going to run in parallel.

        This also checks if we are attempting to create a nested parallel
        loop.
        """
        ...
    
    def configure(self, n_jobs=..., parallel=..., prefer=..., require=..., **memmapping_pool_kwargs): # -> int:
        """Build a process or thread pool and return the number of workers"""
        ...
    
    def terminate(self): # -> None:
        """Shutdown the process or thread pool"""
        ...
    


class LokyBackend(AutoBatchingMixin, ParallelBackendBase):
    """Managing pool of workers with loky instead of multiprocessing."""
    supports_retrieve_callback = ...
    supports_inner_max_num_threads = ...
    def configure(self, n_jobs=..., parallel=..., prefer=..., require=..., idle_worker_timeout=..., **memmapping_executor_kwargs): # -> int:
        """Build a process executor and return the number of workers"""
        ...
    
    def effective_n_jobs(self, n_jobs): # -> int:
        """Determine the number of jobs which are going to run in parallel"""
        ...
    
    def submit(self, func, callback=...): # -> Future:
        """Schedule a func to be run"""
        ...
    
    def retrieve_result_callback(self, future):
        """Retrieve the result, here out is the future given by submit"""
        ...
    
    def terminate(self): # -> None:
        ...
    
    def abort_everything(self, ensure_ready=...): # -> None:
        """Shutdown the workers and restart a new one with the same parameters"""
        ...
    


class FallbackToBackend(Exception):
    """Raised when configuration should fallback to another backend"""
    def __init__(self, backend) -> None:
        ...
    


def inside_dask_worker(): # -> bool:
    """Check whether the current function is executed inside a Dask worker."""
    ...

